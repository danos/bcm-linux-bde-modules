--- a/systems/bde/linux/kernel/linux-kernel-bde.c
+++ b/systems/bde/linux/kernel/linux-kernel-bde.c
@@ -257,6 +257,19 @@ struct bde_spi_device_id {
     uint32  spifreq;
 };
 
+/* Maximum number of I/O windows supported per device. */
+#define BDE_NUM_IOWIN_MAX     3
+
+/* I/O memory window definition. */
+struct memwin_s {
+
+    /* Physical address of I/O window. */
+    resource_size_t addr;
+
+    /* Size of I/O window (in bytes). */
+    resource_size_t size;
+};
+
 /* Control Data */
 typedef struct bde_ctrl_s {
     struct list_head list;
@@ -286,10 +299,7 @@ typedef struct bde_ctrl_s {
     struct device *dma_dev;
 #endif
 
-    /* Physical addresses */
-    resource_size_t phys_address;
-    resource_size_t phys_address1;
-    resource_size_t phys_address2;
+    struct memwin_s iowin[BDE_NUM_IOWIN_MAX];
 
     /* Secondary mapped base address */
     sal_vaddr_t alt_base_addr;
@@ -433,10 +443,10 @@ static void *cpu_address = NULL;
 
 #define IHOST_GICD_REG_ADDR_VALID(d, addr) \
     (_devices[d].bde_dev.base_address1 && \
-    (addr & 0xFFFFFF00) == _devices[d].phys_address1)
+    (addr & 0xFFFFFF00) == _devices[d].iowin[1].addr)
 
 #define IHOST_GICD_REG_ADDR_REMAP(d, addr) \
-    (void *)(_devices[d].bde_dev.base_address1 + (addr - _devices[d].phys_address1))
+    (void *)(_devices[d].bde_dev.base_address1 + (addr - _devices[d].iowin[1].addr))
 
 static uint32_t _read(int d, uint32_t addr);
 
@@ -555,7 +565,8 @@ _eb_device_create(resource_size_t paddr,
 
     /* Map in the device */
     ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(paddr, 0x10000);
-    ctrl->phys_address = paddr;
+    ctrl->iowin[0].addr = paddr;
+    ctrl->iowin[0].size = 0x10000;
 
     dev_rev_id = _read(dev_id, 0x178);  /* CMIC_DEV_REV_ID */
 
@@ -591,7 +602,8 @@ sand_device_create(void)
 
     /* Map in the device */ /* FIX_ME: not realy map anything */
     ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(0x40000000, 0x100000);
-    ctrl->phys_address = 0x40000000;
+    ctrl->iowin[0].addr = 0x40000000;
+    ctrl->iowin[0].size = 0x100000;
 
     ctrl->iLine = 0;
     ctrl->isr = NULL;
@@ -696,7 +708,8 @@ iproc_cmicd_probe(struct platform_device
         gprintk("Error mapping iProc CMIC registers");
         return -1;
     }
-    ctrl->phys_address = memres->start;
+    ctrl->iowin[0].addr = memres->start;
+    ctrl->iowin[0].size = size;
 
 #ifdef CONFIG_OF
     if (of_find_compatible_node(NULL, NULL, IPROC_CMICX_COMPATIBLE)) {
@@ -713,16 +726,18 @@ iproc_cmicd_probe(struct platform_device
         memres = iproc_platform_get_resource(pldev, IORESOURCE_MEM, 1);
         if (memres) {
             ctrl->bde_dev.base_address1 = (sal_vaddr_t)IOREMAP(memres->start, memres->end - memres->start + 1);
-            ctrl->phys_address1 = memres->start;
+            ctrl->iowin[1].addr = memres->start;
+            ctrl->iowin[1].size = memres->end - memres->start + 1;
         } else {
             /* Use default address if not available in DTB */
             ctrl->bde_dev.base_address1 = (sal_vaddr_t)IOREMAP(IHOST_GICD_REG_ADDR, IHOST_GICD_REG_REMAP_LEN);
-            ctrl->phys_address1 = IHOST_GICD_REG_ADDR;
+            ctrl->iowin[1].addr = IHOST_GICD_REG_ADDR;
+            ctrl->iowin[1].size = IHOST_GICD_REG_REMAP_LEN;
         }
         if (ctrl->bde_dev.base_address1) {
             if (debug >= 1) {
                 gprintk("base_address1:0x%lx phys_address1:0x%lx\n",
-                        (unsigned long)ctrl->bde_dev.base_address1, (unsigned long)ctrl->phys_address1);
+                        (unsigned long)ctrl->bde_dev.base_address1, (unsigned long)ctrl->iowin[1].addr);
             }
         } else {
             gprintk("Error mapping ihost GICD registers\n");
@@ -1020,7 +1035,8 @@ _ics_bde_create(void)
         /* Map in the device */
         paddr = BCM_ICS_CMIC_BASE;
         ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(paddr, 0x10000);
-        ctrl->phys_address = paddr;
+        ctrl->iowin[0].addr = paddr;
+        ctrl->iowin[0].size = 0x10000;
 
         dev_rev_id = *((unsigned int *)(KSEG1ADDR(paddr + 0x178)));
 
@@ -2181,7 +2197,7 @@ _pci_probe(struct pci_dev *dev, const st
     resource_size_t paddr;
     uint16  cmd = 0;
     uint32 bar_len;
-    int cmic_bar;
+    int i, cmic_bar;
     int baroff = 0;
     int iproc = 0;
     int plx_dev = 0;
@@ -2568,13 +2584,21 @@ _pci_probe(struct pci_dev *dev, const st
     }
 
     ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(paddr, bar_len);
-    ctrl->phys_address = paddr;
+    ctrl->iowin[0].addr = paddr;
+    ctrl->iowin[0].size = bar_len;
+
     if (debug >= 3) {
         gprintk("BAR %d: kernel addr:0x%lx phys addr:0x%lx length:%lx\n",
           baroff, (unsigned long)ctrl->bde_dev.base_address, (unsigned long)paddr, (unsigned long)bar_len);
     }
 
     /* Map secondary address spaces */
+    for (i = 1; i < BDE_NUM_IOWIN_MAX; i++) {
+        ctrl->iowin[i].addr = 0;
+        ctrl->iowin[i].size = 0;
+    }
+    ctrl->bde_dev.base_address1 = 0;
+
     if (iproc
 #ifdef DNX_TEST_BOARD
         || (dev->device == PLX9056_DEVICE_ID && baroff == 2)
@@ -2583,7 +2607,8 @@ _pci_probe(struct pci_dev *dev, const st
         paddr = pci_resource_start(dev, 0);
         bar_len = pci_resource_len(dev, 0);
         ctrl->bde_dev.base_address1 = (sal_vaddr_t)IOREMAP(paddr, bar_len);
-        ctrl->phys_address1 = paddr;
+        ctrl->iowin[1].addr = paddr;
+        ctrl->iowin[1].size = bar_len;
         if (debug >= 3) {
             gprintk("BAR 0: kernel addr:0x%lx phys addr:0x%lx length:%lx\n",
               (unsigned long)ctrl->bde_dev.base_address1, (unsigned long)paddr, (unsigned long)bar_len);
@@ -2784,7 +2809,8 @@ map_local_bus(uint64_t addr, uint32_t si
 
     /* Map in the device */
     ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(addr, size);
-    ctrl->phys_address = addr;
+    ctrl->iowin[0].addr = addr;
+    ctrl->iowin[0].size = size;
 
     _bde_add_device();
     return(ctrl);
@@ -2828,7 +2854,8 @@ map_local_bus2(bde_ctrl_t *plx_ctrl, uin
 
     /* Map in the device */
     ctrl->bde_dev.base_address = plx_ctrl->bde_dev.base_address + dev_base;
-    ctrl->phys_address = plx_ctrl->phys_address + (resource_size_t)dev_base;
+    ctrl->iowin[0].addr = plx_ctrl->iowin[0].addr + (resource_size_t)dev_base;
+    ctrl->iowin[0].size = size;
 
 #if 1
     addr = (uint8_t *)ctrl->bde_dev.base_address + PL0_REVISION_REG;
@@ -2861,12 +2888,12 @@ probe_plx_local_bus(void)
     }
     addr_hi_str[0] = 0;
 #ifdef PHYS_ADDR_IS_64BIT
-    sprintf(addr_hi_str, "%08x", (uint32_t)(plx_ctrl.phys_address >> 32));
+    sprintf(addr_hi_str, "%08x", (uint32_t)(plx_ctrl.iowin[0].addr >> 32));
 #endif
     printk(KERN_ERR "Found PLX %04x:%04x vir: 0x%08x phy: 0x%s%08x\n",
            plx_ctrl.bde_dev.device, plx_ctrl.bde_dev.rev,
            plx_ctrl.bde_dev.base_address, addr_hi_str,
-           (uint32_t)(plx_ctrl.phys_address)); 
+           (uint32_t)(plx_ctrl.iowin[0].addr));
 
     addr = (uint8_t *)plx_ctrl.bde_dev.base_address + CPLD_OFFSET + CPLD_REVISION_REG;
     val = readl(addr);
@@ -3145,7 +3172,7 @@ _pprint(void)
             pprintf("AXI Device 0x%x:0x%x:0x%.8lx:%d\n",
                     ctrl->bde_dev.device,
                     ctrl->bde_dev.rev,
-                    (unsigned long)ctrl->phys_address,
+                    (unsigned long)ctrl->iowin[0].addr,
                     ctrl->iLine);
         } else if (ctrl->dev_type & BDE_EB_DEV_TYPE) {
             pprintf("EB Bus Device 0x%x:0x%x\n",
@@ -3161,6 +3188,54 @@ _pprint(void)
     }
     return 0;
 }
+/*
+ * Some kernels are configured to prevent mapping of kernel RAM memory
+ * into user space via the /dev/mem device.
+ *
+ * The function below provides a backdoor to map IO and DMA memory to
+ * user space via the BDE device file.
+ */
+static int
+_bde_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long paddr = vma->vm_pgoff << PAGE_SHIFT;
+    unsigned long size = vma->vm_end - vma->vm_start;
+    int i, j, pio_range_valid = 0;
+
+    for(i = 0; i < _ndevices; i++) {
+        bde_ctrl_t *ctrl = _devices + i;
+        if (ctrl->dev_type & BDE_SWITCH_DEV_TYPE) {
+            for (j = 0; j < BDE_NUM_IOWIN_MAX; j++) {
+                if (paddr >= (unsigned long)ctrl->iowin[j].addr &&
+                    (paddr + size) <= (unsigned long)(ctrl->iowin[j].addr + ctrl->iowin[j].size)) {
+                    pio_range_valid = 1;
+                    break;
+                }
+                if ((ctrl->dev_type & BDE_AXI_DEV_TYPE) && (paddr == ctrl->iowin[j].addr)) {
+                    pio_range_valid = 1;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (pio_range_valid) {
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (remap_pfn_range(vma,
+                        vma->vm_start,
+                        vma->vm_pgoff,
+                        size,
+                        vma->vm_page_prot)) {
+            gprintk("Failed to mmap phys range 0x%lx-0x%lx to 0x%lx-0x%lx\n",
+                paddr, paddr + size, vma->vm_start,vma->vm_end);
+            return -EAGAIN;
+        }
+        return 0;
+    }
+
+    return _dma_mmap(filp, vma);
+}
 
 /* Workaround for broken Busybox/PPC insmod */
 static char _modname[] = LINUX_KERNEL_BDE_NAME;
@@ -3171,7 +3246,7 @@ static gmodule_t _gmodule = {
     init: _init,
     cleanup: _cleanup,
     pprint: _pprint,
-    mmap: _dma_mmap,
+    mmap: _bde_mmap,
 };
 
 gmodule_t *
@@ -3946,14 +4021,14 @@ lkbde_cpu_pci_register(int d)
     if (ctrl->bde_dev.base_address) {
         iounmap((void *)ctrl->bde_dev.base_address);
     }
-    ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(ctrl->phys_address, 0x1000000);
+    ctrl->bde_dev.base_address = (sal_vaddr_t)IOREMAP(ctrl->iowin[0].addr, 0x1000000);
 
     if (debug >= 1) {
         gprintk("%s, %s(): info:\n", __FILE__, __FUNCTION__);
         gprintk("_ndevices=%d, _switch_ndevices=%d\n",
                 _ndevices, _switch_ndevices);
         gprintk("ctrl->dev_type=0x%x, ctrl->phys_address=0x%lx\n",
-                ctrl->dev_type, (unsigned long)ctrl->phys_address);
+                ctrl->dev_type, (unsigned long)ctrl->iowin[0].addr);
         gprintk("ctrl->bde_dev.device=0x%x, ctrl->bde_dev.rev=0x%x, "
                 "ctrl->bde_dev.base_address=0x%lx\n",
                 ctrl->bde_dev.device, ctrl->bde_dev.rev,
@@ -4100,7 +4175,7 @@ lkbde_get_dev_phys(int d)
                 d, _devices[d].dev_type);
         return 0;
     }
-    return _devices[d].phys_address;
+    return _devices[d].iowin[0].addr;
 }
 
 uint32_t
@@ -4116,7 +4191,7 @@ lkbde_get_dev_phys_hi(int d)
         return 0;
     }
 #ifdef PHYS_ADDR_IS_64BIT
-    return (uint32_t)(_devices[d].phys_address >> 32);
+    return (uint32_t)(_devices[d].iowin[0].addr >> 32);
 #else
     return 0;
 #endif
@@ -4162,15 +4237,15 @@ lkbde_get_dev_resource(int d, int rsrc,
 
     switch (rsrc) {
     case 0:
-        *phys_lo = (uint32_t)(_devices[d].phys_address);
+        *phys_lo = (uint32_t)(_devices[d].iowin[0].addr);
 #ifdef PHYS_ADDR_IS_64BIT
-        *phys_hi = (uint32_t)(_devices[d].phys_address >> 32);
+        *phys_hi = (uint32_t)(_devices[d].iowin[0].addr >> 32);
 #endif
         break;
     case 1:
-        *phys_lo = (uint32_t)(_devices[d].phys_address1);
+        *phys_lo = (uint32_t)(_devices[d].iowin[1].addr);
 #ifdef PHYS_ADDR_IS_64BIT
-        *phys_hi = (uint32_t)(_devices[d].phys_address1 >> 32);
+        *phys_hi = (uint32_t)(_devices[d].iowin[1].addr >> 32);
 #endif
         break;
     default:
